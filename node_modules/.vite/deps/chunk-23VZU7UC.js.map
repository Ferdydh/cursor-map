{
  "version": 3,
  "sources": ["../../@langchain/core/dist/messages/modifier.js", "../../@langchain/core/dist/messages/transformers.js"],
  "sourcesContent": ["import { BaseMessage } from \"./base.js\";\n/**\n * Message responsible for deleting other messages.\n */\nexport class RemoveMessage extends BaseMessage {\n    constructor(fields) {\n        super({\n            ...fields,\n            content: \"\",\n        });\n        /**\n         * The ID of the message to remove.\n         */\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.id = fields.id;\n    }\n    _getType() {\n        return \"remove\";\n    }\n    get _printableFields() {\n        return {\n            ...super._printableFields,\n            id: this.id,\n        };\n    }\n}\n", "import { RunnableLambda } from \"../runnables/base.js\";\nimport { AIMessage, AIMessageChunk } from \"./ai.js\";\nimport { ChatMessage, ChatMessageChunk, } from \"./chat.js\";\nimport { FunctionMessage, FunctionMessageChunk, } from \"./function.js\";\nimport { HumanMessage, HumanMessageChunk } from \"./human.js\";\nimport { RemoveMessage } from \"./modifier.js\";\nimport { SystemMessage, SystemMessageChunk } from \"./system.js\";\nimport { ToolMessage, ToolMessageChunk, } from \"./tool.js\";\nimport { convertToChunk } from \"./utils.js\";\nconst _isMessageType = (msg, types) => {\n    const typesAsStrings = [\n        ...new Set(types?.map((t) => {\n            if (typeof t === \"string\") {\n                return t;\n            }\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const instantiatedMsgClass = new t({});\n            if (!(\"_getType\" in instantiatedMsgClass) ||\n                typeof instantiatedMsgClass._getType !== \"function\") {\n                throw new Error(\"Invalid type provided.\");\n            }\n            return instantiatedMsgClass._getType();\n        })),\n    ];\n    const msgType = msg._getType();\n    return typesAsStrings.some((t) => t === msgType);\n};\nexport function filterMessages(messagesOrOptions, options) {\n    if (Array.isArray(messagesOrOptions)) {\n        return _filterMessages(messagesOrOptions, options);\n    }\n    return RunnableLambda.from((input) => {\n        return _filterMessages(input, messagesOrOptions);\n    });\n}\nfunction _filterMessages(messages, options = {}) {\n    const { includeNames, excludeNames, includeTypes, excludeTypes, includeIds, excludeIds, } = options;\n    const filtered = [];\n    for (const msg of messages) {\n        if (excludeNames && msg.name && excludeNames.includes(msg.name)) {\n            continue;\n        }\n        else if (excludeTypes && _isMessageType(msg, excludeTypes)) {\n            continue;\n        }\n        else if (excludeIds && msg.id && excludeIds.includes(msg.id)) {\n            continue;\n        }\n        // default to inclusion when no inclusion criteria given.\n        if (!(includeTypes || includeIds || includeNames)) {\n            filtered.push(msg);\n        }\n        else if (includeNames &&\n            msg.name &&\n            includeNames.some((iName) => iName === msg.name)) {\n            filtered.push(msg);\n        }\n        else if (includeTypes && _isMessageType(msg, includeTypes)) {\n            filtered.push(msg);\n        }\n        else if (includeIds && msg.id && includeIds.some((id) => id === msg.id)) {\n            filtered.push(msg);\n        }\n    }\n    return filtered;\n}\nexport function mergeMessageRuns(messages) {\n    if (Array.isArray(messages)) {\n        return _mergeMessageRuns(messages);\n    }\n    return RunnableLambda.from(_mergeMessageRuns);\n}\nfunction _mergeMessageRuns(messages) {\n    if (!messages.length) {\n        return [];\n    }\n    const merged = [];\n    for (const msg of messages) {\n        const curr = msg; // Create a shallow copy of the message\n        const last = merged.pop();\n        if (!last) {\n            merged.push(curr);\n        }\n        else if (curr._getType() === \"tool\" ||\n            !(curr._getType() === last._getType())) {\n            merged.push(last, curr);\n        }\n        else {\n            const lastChunk = convertToChunk(last);\n            const currChunk = convertToChunk(curr);\n            const mergedChunks = lastChunk.concat(currChunk);\n            if (typeof lastChunk.content === \"string\" &&\n                typeof currChunk.content === \"string\") {\n                mergedChunks.content = `${lastChunk.content}\\n${currChunk.content}`;\n            }\n            merged.push(_chunkToMsg(mergedChunks));\n        }\n    }\n    return merged;\n}\nexport function trimMessages(messagesOrOptions, options) {\n    if (Array.isArray(messagesOrOptions)) {\n        const messages = messagesOrOptions;\n        if (!options) {\n            throw new Error(\"Options parameter is required when providing messages.\");\n        }\n        return _trimMessagesHelper(messages, options);\n    }\n    else {\n        const trimmerOptions = messagesOrOptions;\n        return RunnableLambda.from((input) => _trimMessagesHelper(input, trimmerOptions));\n    }\n}\nasync function _trimMessagesHelper(messages, options) {\n    const { maxTokens, tokenCounter, strategy = \"last\", allowPartial = false, endOn, startOn, includeSystem = false, textSplitter, } = options;\n    if (startOn && strategy === \"first\") {\n        throw new Error(\"`startOn` should only be specified if `strategy` is 'last'.\");\n    }\n    if (includeSystem && strategy === \"first\") {\n        throw new Error(\"`includeSystem` should only be specified if `strategy` is 'last'.\");\n    }\n    let listTokenCounter;\n    if (\"getNumTokens\" in tokenCounter) {\n        listTokenCounter = async (msgs) => {\n            const tokenCounts = await Promise.all(msgs.map((msg) => tokenCounter.getNumTokens(msg.content)));\n            return tokenCounts.reduce((sum, count) => sum + count, 0);\n        };\n    }\n    else {\n        listTokenCounter = async (msgs) => tokenCounter(msgs);\n    }\n    let textSplitterFunc = defaultTextSplitter;\n    if (textSplitter) {\n        if (\"splitText\" in textSplitter) {\n            textSplitterFunc = textSplitter.splitText;\n        }\n        else {\n            textSplitterFunc = async (text) => textSplitter(text);\n        }\n    }\n    if (strategy === \"first\") {\n        return _firstMaxTokens(messages, {\n            maxTokens,\n            tokenCounter: listTokenCounter,\n            textSplitter: textSplitterFunc,\n            partialStrategy: allowPartial ? \"first\" : undefined,\n            endOn,\n        });\n    }\n    else if (strategy === \"last\") {\n        return _lastMaxTokens(messages, {\n            maxTokens,\n            tokenCounter: listTokenCounter,\n            textSplitter: textSplitterFunc,\n            allowPartial,\n            includeSystem,\n            startOn,\n            endOn,\n        });\n    }\n    else {\n        throw new Error(`Unrecognized strategy: '${strategy}'. Must be one of 'first' or 'last'.`);\n    }\n}\nasync function _firstMaxTokens(messages, options) {\n    const { maxTokens, tokenCounter, textSplitter, partialStrategy, endOn } = options;\n    let messagesCopy = [...messages];\n    let idx = 0;\n    for (let i = 0; i < messagesCopy.length; i += 1) {\n        const remainingMessages = i > 0 ? messagesCopy.slice(0, -i) : messagesCopy;\n        if ((await tokenCounter(remainingMessages)) <= maxTokens) {\n            idx = messagesCopy.length - i;\n            break;\n        }\n    }\n    if (idx < messagesCopy.length - 1 && partialStrategy) {\n        let includedPartial = false;\n        if (Array.isArray(messagesCopy[idx].content)) {\n            const excluded = messagesCopy[idx];\n            if (typeof excluded.content === \"string\") {\n                throw new Error(\"Expected content to be an array.\");\n            }\n            const numBlock = excluded.content.length;\n            const reversedContent = partialStrategy === \"last\"\n                ? [...excluded.content].reverse()\n                : excluded.content;\n            for (let i = 1; i <= numBlock; i += 1) {\n                const partialContent = partialStrategy === \"first\"\n                    ? reversedContent.slice(0, i)\n                    : reversedContent.slice(-i);\n                const fields = Object.fromEntries(Object.entries(excluded).filter(([k]) => k !== \"type\" && !k.startsWith(\"lc_\")));\n                const updatedMessage = _switchTypeToMessage(excluded._getType(), {\n                    ...fields,\n                    content: partialContent,\n                });\n                const slicedMessages = [...messagesCopy.slice(0, idx), updatedMessage];\n                if ((await tokenCounter(slicedMessages)) <= maxTokens) {\n                    messagesCopy = slicedMessages;\n                    idx += 1;\n                    includedPartial = true;\n                }\n                else {\n                    break;\n                }\n            }\n            if (includedPartial && partialStrategy === \"last\") {\n                excluded.content = [...reversedContent].reverse();\n            }\n        }\n        if (!includedPartial) {\n            const excluded = messagesCopy[idx];\n            let text;\n            if (Array.isArray(excluded.content) &&\n                excluded.content.some((block) => typeof block === \"string\" || block.type === \"text\")) {\n                const textBlock = excluded.content.find((block) => block.type === \"text\" && block.text);\n                text = textBlock?.text;\n            }\n            else if (typeof excluded.content === \"string\") {\n                text = excluded.content;\n            }\n            if (text) {\n                const splitTexts = await textSplitter(text);\n                const numSplits = splitTexts.length;\n                if (partialStrategy === \"last\") {\n                    splitTexts.reverse();\n                }\n                for (let _ = 0; _ < numSplits - 1; _ += 1) {\n                    splitTexts.pop();\n                    excluded.content = splitTexts.join(\"\");\n                    if ((await tokenCounter([...messagesCopy.slice(0, idx), excluded])) <=\n                        maxTokens) {\n                        if (partialStrategy === \"last\") {\n                            excluded.content = [...splitTexts].reverse().join(\"\");\n                        }\n                        messagesCopy = [...messagesCopy.slice(0, idx), excluded];\n                        idx += 1;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    if (endOn) {\n        const endOnArr = Array.isArray(endOn) ? endOn : [endOn];\n        while (idx > 0 && !_isMessageType(messagesCopy[idx - 1], endOnArr)) {\n            idx -= 1;\n        }\n    }\n    return messagesCopy.slice(0, idx);\n}\nasync function _lastMaxTokens(messages, options) {\n    const { allowPartial = false, includeSystem = false, endOn, startOn, ...rest } = options;\n    if (endOn) {\n        const endOnArr = Array.isArray(endOn) ? endOn : [endOn];\n        while (messages &&\n            !_isMessageType(messages[messages.length - 1], endOnArr)) {\n            messages.pop();\n        }\n    }\n    const swappedSystem = includeSystem && messages[0]._getType() === \"system\";\n    let reversed_ = swappedSystem\n        ? messages.slice(0, 1).concat(messages.slice(1).reverse())\n        : messages.reverse();\n    reversed_ = await _firstMaxTokens(reversed_, {\n        ...rest,\n        partialStrategy: allowPartial ? \"last\" : undefined,\n        endOn: startOn,\n    });\n    if (swappedSystem) {\n        return [reversed_[0], ...reversed_.slice(1).reverse()];\n    }\n    else {\n        return reversed_.reverse();\n    }\n}\nconst _MSG_CHUNK_MAP = {\n    human: {\n        message: HumanMessage,\n        messageChunk: HumanMessageChunk,\n    },\n    ai: {\n        message: AIMessage,\n        messageChunk: AIMessageChunk,\n    },\n    system: {\n        message: SystemMessage,\n        messageChunk: SystemMessageChunk,\n    },\n    tool: {\n        message: ToolMessage,\n        messageChunk: ToolMessageChunk,\n    },\n    function: {\n        message: FunctionMessage,\n        messageChunk: FunctionMessageChunk,\n    },\n    generic: {\n        message: ChatMessage,\n        messageChunk: ChatMessageChunk,\n    },\n    remove: {\n        message: RemoveMessage,\n        messageChunk: RemoveMessage, // RemoveMessage does not have a chunk class.\n    },\n};\nfunction _switchTypeToMessage(messageType, fields, returnChunk) {\n    let chunk;\n    let msg;\n    switch (messageType) {\n        case \"human\":\n            if (returnChunk) {\n                chunk = new HumanMessageChunk(fields);\n            }\n            else {\n                msg = new HumanMessage(fields);\n            }\n            break;\n        case \"ai\":\n            if (returnChunk) {\n                let aiChunkFields = {\n                    ...fields,\n                };\n                if (\"tool_calls\" in aiChunkFields) {\n                    aiChunkFields = {\n                        ...aiChunkFields,\n                        tool_call_chunks: aiChunkFields.tool_calls?.map((tc) => ({\n                            ...tc,\n                            type: \"tool_call_chunk\",\n                            index: undefined,\n                            args: JSON.stringify(tc.args),\n                        })),\n                    };\n                }\n                chunk = new AIMessageChunk(aiChunkFields);\n            }\n            else {\n                msg = new AIMessage(fields);\n            }\n            break;\n        case \"system\":\n            if (returnChunk) {\n                chunk = new SystemMessageChunk(fields);\n            }\n            else {\n                msg = new SystemMessage(fields);\n            }\n            break;\n        case \"tool\":\n            if (\"tool_call_id\" in fields) {\n                if (returnChunk) {\n                    chunk = new ToolMessageChunk(fields);\n                }\n                else {\n                    msg = new ToolMessage(fields);\n                }\n            }\n            else {\n                throw new Error(\"Can not convert ToolMessage to ToolMessageChunk if 'tool_call_id' field is not defined.\");\n            }\n            break;\n        case \"function\":\n            if (returnChunk) {\n                chunk = new FunctionMessageChunk(fields);\n            }\n            else {\n                if (!fields.name) {\n                    throw new Error(\"FunctionMessage must have a 'name' field\");\n                }\n                msg = new FunctionMessage(fields);\n            }\n            break;\n        case \"generic\":\n            if (\"role\" in fields) {\n                if (returnChunk) {\n                    chunk = new ChatMessageChunk(fields);\n                }\n                else {\n                    msg = new ChatMessage(fields);\n                }\n            }\n            else {\n                throw new Error(\"Can not convert ChatMessage to ChatMessageChunk if 'role' field is not defined.\");\n            }\n            break;\n        default:\n            throw new Error(`Unrecognized message type ${messageType}`);\n    }\n    if (returnChunk && chunk) {\n        return chunk;\n    }\n    if (msg) {\n        return msg;\n    }\n    throw new Error(`Unrecognized message type ${messageType}`);\n}\nfunction _chunkToMsg(chunk) {\n    const chunkType = chunk._getType();\n    let msg;\n    const fields = Object.fromEntries(Object.entries(chunk).filter(([k]) => ![\"type\", \"tool_call_chunks\"].includes(k) && !k.startsWith(\"lc_\")));\n    if (chunkType in _MSG_CHUNK_MAP) {\n        msg = _switchTypeToMessage(chunkType, fields);\n    }\n    if (!msg) {\n        throw new Error(`Unrecognized message chunk class ${chunkType}. Supported classes are ${Object.keys(_MSG_CHUNK_MAP)}`);\n    }\n    return msg;\n}\n/**\n * The default text splitter function that splits text by newlines.\n *\n * @param {string} text\n * @returns A promise that resolves to an array of strings split by newlines.\n */\nexport function defaultTextSplitter(text) {\n    const splits = text.split(\"\\n\");\n    return Promise.resolve([\n        ...splits.slice(0, -1).map((s) => `${s}\\n`),\n        splits[splits.length - 1],\n    ]);\n}\n"],
  "mappings": "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",
  "names": []
}
